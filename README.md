# Recipe Server
Author: Jason Gonzales

## Overview (What I did)

Additional technical details are below the overview section.

### Features

- A Sqlite database and Axum web service including:
  - Askama-templated HTML UI on `http://127.0.0.1:3000`.
  - Utoipa-documented REST API with link on webpage and through documentation paths listed below.
  - JSON web token authentication that uses an access code.
  - An `api/v1/add-recipe` route that requires a valid JWT for authorization.
- Leptos frontend in `frontend/` that runs a webpage that fetches data from the REST API.
- A `Dockerfile` to run the axum web service.
- A shell script to demonstrate authentication and adding a new recipe.

### Website

This project implements a webpage that first serves a random recipe and updates
the URL with the an `id` as part of the query string. Tags can be searched and
the Swagger UI documentation can be access via a hyperlink.

### Docker

A `Dockerfile` is included to containerize the Axum web service.

### REST API

The REST API is built using Axum and provides structured access to recipe data. It is documented 
using utoipa, which generates OpenAPI documentation. Recipes can be retrieved by ID or through tags
and new recipes can be added through an authorized call to the API.

### Client-Side Rendering

The `frontend/` directory contains a Leptos client that dynamically fetches and displays recipe 
data from the REST API. 

## Development Experience (How it went)

I enjoyed learning multiple facets of Axum and seeing where there are more avenues for future work
such as using OAuth to login with another service such as Google. For the webpage UI Askama felt 
intuitive to me as I had worked with Jinja for Python and EJS for JavaScript previously. I updated
the CSS style to give a simple box shadow around the main body of the recipes. This helped break
up the page from the metadata below it.

Autogenerated OpenAPI documentation was entirely new to me. Having the documentation as an attribute 
macro next to the function is a great development experience as I can directly see both the
documentation and the function on the same window. I built routes for Swagger UI, Redocly, and 
RapiDoc (all listed below), but I have a personal preference for Swagger UI. I like that I am
able to test the API from that interface. I also used curl and Postman at different points
to test the REST API and the getting a JWT to allow a user to add a recipe.

I found Docker to be challenging to work with for my setup. I am running WSL2 from Windows for
the development of this project. To get it working I needed to install Docker Desktop and then
follow instructions to get the `docker` command running in WSL2. However I had trouble with
Docker Desktop hanging on startup and once that was resolved I had further issues with the
`docker` command frequently hanging for basic commands like `docker ps`. This left the process
being slow to build for and to develop. It did help me realize thought that my sqlx queries
were outdated.

Leptos was interesting to work on, although I leaned heavily on the knock-knock version to
get things running. I found external sources to be more confusing when working on adapting 
Bart's code to work for my recipe server data. I really like the dynamic nature of calling
the REST API though and it populating the web page. I look forward to experimenting more with this
framework.

## Setup & Development

```sh
cargo install sqlx-cli
mkdir db && sqlx database create --database-url sqlite://db/recipes.db
```

Make `.env` file with database path `DATABASE_URL=sqlite://db/recipes.db`

Create migrations:
```sh
sqlx migrate add -r -s <name>
```

Apply migration:
```sh
sqlx migrate run --database-url sqlite://db/recipes.db
```

First run to add recipes from `.json` file:
```sh
cargo run -- --init-from assets/static/recipes.json
```

`cargo run --release`: This will run the server on `http://127.0.0.1:3000`

## REST API Documentation Paths

- `/swagger-ui`: Swagger UI Documentation Layout
- `/redoc`: Redocly Documentation Layout
- `/rapidoc`: RapiDoc Documentation Layout  

## REST API Registration

Using a POST request to `/api/v1/register` provide your name and email with
the access code: `openinvite`. Currently the access code acts as an invite code
for the server to allow a user to perform authorized actions with the REST API.

```json
{
    "full_name": "First Last",
    "email": "firstlast@example.com",
    "access_code": "openinvite"
}
```

## Docker

Make sure SQL queries are precompiled
```sh
cargo sqlx prepare
```

From the project root (same directory as `Dockerfile`) build the docker image:
```sh
docker build -t recipe-server .
```

Expose port 3000 to access the server
```sh
docker run -p 3000:3000 recipe-server
```

## Frontend

The `frontend/` directory contains a dynamic Leptos web frontend that consumes the backend REST API 
that runs from the outer project on `http://127.0.0.1:3000/api/v1/`.

```sh
cd frontend/
trunk serve --open
```
This will run the frontend on `http://127.0.0.1:8080`

To build the frontend for deployment:
```sh
trunk build --release
```
This will output static assets to `dist/`.

## Testing

Below is an entry in the JSON data and database for query testing.
```json
{
    "id": "test",
    "title": "Test Recipe",
    "ingredients": "1/2 an ingredient\n1 cup second ingredient",
    "instructions": "Combine first ingredient and second ingredient.\nCook until ready to serve.",
    "source": "test",
    "tags": ["test"]
}
```

## Notes

The favicon.ico was made using PowerPoint and the basic shapes tool to create a cooking pot.

### Tracing Resources

[Adding Logging & Tracing Overview](https://carlosmv.hashnode.dev/adding-logging-and-tracing-to-an-axum-app-rust)
[Tokio: Getting started with Tracing](https://tokio.rs/tokio/topics/tracing)
[EnvFilter Examples](https://docs.rs/tracing-subscriber/latest/tracing_subscriber/filter/struct.EnvFilter.html#examples)
